@Tutorial(time: 25) {
    @Intro(title: "Loading DICOM Series") {
        Master loading and assembling multi-slice DICOM volumes.

        Learn how to load DICOM series from directories, automatically order slices by anatomical position, validate geometric consistency, and access 3D volume data. You'll explore synchronous and asynchronous loading, progress tracking, and volume geometry extraction.

        @Image(source: "series-loading-intro.png", alt: "DICOM series volume assembly")
    }

    @Section(title: "Understanding DICOM Series") {
        @ContentAndMedia {
            DICOM series are collections of 2D slices that form 3D volumes. Each slice represents a cross-section at a specific anatomical position.

            The ``DicomSeriesLoader`` automatically orders slices by their Image Position (Patient) coordinates, validates consistency across the series, and assembles them into a contiguous 3D volume buffer with complete geometric metadata.

            @Image(source: "series-concept.png", alt: "DICOM series concept")
        }

        @Steps {
            @Step {
                Create a DicomSeriesLoader instance with the default decoder factory.

                The loader uses dependency injection to create decoders for each DICOM file, ensuring clean state and thread-safe processing.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "create-loader.png", alt: "Create series loader")
                }
            }

            @Step {
                Load a series from a directory containing DICOM files.

                The loader scans the directory, loads each slice, validates consistency, orders by position, and assembles the volume.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "load-series.png", alt: "Load series")
                }
            }

            @Step {
                Access the volume dimensions and metadata.

                The ``DicomSeriesVolume`` structure provides width, height, depth, and complete geometric information.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "volume-info.png", alt: "Volume information")
                }
            }

            @Step {
                Handle potential errors during series loading.

                Common errors include no DICOM files found, inconsistent dimensions, and unsupported formats.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "handle-errors.png", alt: "Handle loading errors")
                }
            }
        }
    }

    @Section(title: "Progress Tracking") {
        @ContentAndMedia {
            Monitor loading progress for large series to provide user feedback during assembly.

            The loader supports progress callbacks that report completion fraction, slice count, and current file being processed.

            @Image(source: "progress-tracking.png", alt: "Progress tracking")
        }

        @Steps {
            @Step {
                Add a progress handler to track loading status.

                The progress callback receives fraction complete (0.0 to 1.0), total slice count, current slice index, and file URL.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "progress-handler.png", alt: "Progress handler")
                }
            }

            @Step {
                Update UI elements from the progress handler.

                Use the progress fraction to update progress bars, labels, and status indicators in your app's interface.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "update-ui.png", alt: "Update UI")
                }
            }
        }
    }

    @Section(title: "Asynchronous Loading") {
        @ContentAndMedia {
            Load series asynchronously to avoid blocking the main thread during lengthy I/O operations.

            The async API integrates with Swift Concurrency, providing non-blocking loading with progress streams.

            @Image(source: "async-loading.png", alt: "Asynchronous loading")
        }

        @Steps {
            @Step {
                Use the async throwing variant to load series in the background.

                The async method works identically to the synchronous version but doesn't block the calling thread.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "async-load.png", alt: "Async load")
                }
            }

            @Step {
                Use loadSeriesWithProgress for streaming progress updates.

                This method returns an AsyncThrowingStream that yields progress updates during loading.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "progress-stream.png", alt: "Progress stream")
                }
            }
        }
    }

    @Section(title: "Volume Geometry") {
        @ContentAndMedia {
            Extract geometric metadata from loaded volumes for 3D reconstruction and measurements.

            The volume includes pixel spacing, orientation matrices, origin position, and rescale parameters needed for accurate spatial representation.

            @Image(source: "volume-geometry.png", alt: "Volume geometry")
        }

        @Steps {
            @Step {
                Access pixel spacing in millimeters.

                The spacing SIMD3 vector provides physical distance between voxels in X, Y, and Z dimensions.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "pixel-spacing.png", alt: "Pixel spacing")
                }
            }

            @Step {
                Get the orientation matrix and origin position.

                The 3Ã—3 orientation matrix defines anatomical axes, while origin specifies the volume's position in patient space.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "orientation.png", alt: "Orientation")
                }
            }

            @Step {
                Calculate physical volume dimensions.

                Multiply pixel dimensions by spacing to get physical size in millimeters.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "physical-dims.png", alt: "Physical dimensions")
                }
            }
        }
    }

    @Section(title: "Accessing Voxel Data") {
        @ContentAndMedia {
            Extract and process the raw voxel data from the assembled volume.

            The voxel buffer is a contiguous Data object containing 16-bit signed integers in row-major order (X varies fastest).

            @Image(source: "voxel-data.png", alt: "Voxel data access")
        }

        @Steps {
            @Step {
                Access the raw voxel buffer.

                The voxels property provides direct access to the contiguous 16-bit data buffer.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "raw-voxels.png", alt: "Raw voxels")
                }
            }

            @Step {
                Convert voxel data to typed array for processing.

                Use withUnsafeBytes to access the buffer as typed Int16 values.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "typed-access.png", alt: "Typed access")
                }
            }

            @Step {
                Apply rescale transformation for Hounsfield Units.

                Use the rescale slope and intercept to convert stored values to modality units (e.g., HU for CT).

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "apply-rescale.png", alt: "Apply rescale")
                }
            }
        }
    }

    @Section(title: "Processing Individual Slices") {
        @ContentAndMedia {
            Extract and process individual 2D slices from the 3D volume.

            Each slice can be windowed independently for visualization or analysis.

            @Image(source: "slice-processing.png", alt: "Slice processing")
        }

        @Steps {
            @Step {
                Extract a specific slice from the volume.

                Calculate the offset into the voxel buffer based on slice index and dimensions.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "extract-slice.png", alt: "Extract slice")
                }
            }

            @Step {
                Apply window/level to a slice for display.

                Use ``DCMWindowingProcessor`` to convert 16-bit slice data to displayable 8-bit values.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "window-slice.png", alt: "Window slice")
                }
            }
        }
    }

    @Section(title: "Dependency Injection") {
        @ContentAndMedia {
            Use custom decoder implementations for testing or specialized loading scenarios.

            The loader accepts a decoder factory closure, enabling dependency injection for testability.

            @Image(source: "dependency-injection.png", alt: "Dependency injection")
        }

        @Steps {
            @Step {
                Create a loader with a custom decoder factory.

                This is particularly useful for unit testing with MockDicomDecoder.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "custom-factory.png", alt: "Custom factory")
                }
            }

            @Step {
                Use the loader with the injected decoder.

                The loading API remains identical regardless of decoder implementation.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "use-injected.png", alt: "Use injected decoder")
                }
            }
        }
    }

    @Section(title: "Complete Workflow") {
        @ContentAndMedia {
            Combine all techniques into a complete series loading and processing pipeline.

            This example demonstrates async loading, progress tracking, geometry extraction, slice processing, and windowing.

            @Image(source: "complete-series-workflow.png", alt: "Complete workflow")
        }

        @Steps {
            @Step {
                Build a complete series processing pipeline.

                This workflow loads a series asynchronously, tracks progress, extracts geometry, processes individual slices, and applies medical presets.

                @Code(name: "SeriesExample.swift", file: SeriesExample.swift) {
                    @Image(source: "full-series-pipeline.png", alt: "Full pipeline")
                }
            }
        }
    }
}
